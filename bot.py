from re import sub
from types import ClassMethodDescriptorType
import praw
import random
import datetime
import time
import os
import markovify

path = os.path.dirname(__file__)

bot_name='polibot-cs40'



# FIXME:
# copy your generate_comment function from the madlibs assignment here
content = ''
with open(path+'/model_data.txt', 'r', encoding='utf-8') as file:
     content = file.read()

model = markovify.Text(content)

starting_points = ['Biden', 'Sleepy Joe', 'Hillary', 'Democrats', 'Republicans', 'GOP', 'Trump', 'I think',]

def generate_comment():
    comment = ''

    i = random.randint(0,3)

    if i == 0:
        for j in range(0,random.randint(1,4)):
            comment = comment + model.make_sentence() + ' '
    if i == 1:
        comment = comment + model.make_sentence_with_start(random.choice(starting_points), strict=False) 
    if i == 2:
        for j in range(0,random.randint(1,3)):
            comment = comment + model.make_sentence_with_start(random.choice(starting_points), strict=False) + ' '
    if i == 3:
        for j in range(0,random.randint(1,3)):
            comment = comment + model.make_sentence_with_start(random.choice(starting_points), strict=False) + ' '
        for j in range(0,random.randint(1,4)):
            comment = comment + model.make_sentence() + ' '

    signature = '''  
    --------  
    I am a bot that is based on the tweets and speeches of Donald J. Trump. [Github link.](https://github.com/HugoMatousek/reddit-bot-with-markovify)'''        

    comment = comment + signature
    return(comment)




# FIXME:
# connect to reddit 
reddit = praw.Reddit('bot1', user_agent='cs40')





# FIXME:
# select a "home" submission in the /r/BotTown subreddit to post to,
# and put the url below
#submission_url = 'https://old.reddit.com/r04cv3'
#submission = reddit.submission(url=submission_url)

# each iteration of this loop will post a single comment;
# since this loop runs forever, your bot will continue posting comments forever;
# (this is what makes it a deamon);
# recall that you can press CTRL-C in the terminal to stop your bot
#
# HINT:
# while you are writing and debugging your code, 
# you probably don't want it to run in an infinite loop;
# you can change this while loop to an if statement to make the code run only once

while True:
        
    try:

        subreddit = reddit.subreddit("BotTown")

        num_sub = 0
        sub_list = []
        for submission in subreddit.hot(limit=10):
            print(submission.title)
            if not submission.is_self:
                sub_list.append(submission)
                num_sub += 1
            if num_sub == 5:
                break

        submission = random.choice(sub_list)

        # printing the current time will help make the output messages more informative
        # since things on reddit vary with time
        print()
        print('new iteration at:',datetime.datetime.now())
        print('submission.title=',submission.title)
        print('submission.id=',submission.id)
        print('submission.url=',submission.url)

        # FIXME (task 0): get a list of all of the comments in the submission
        # HINT: this requires using the .list() and the .replace_more() functions
        submission.comments.replace_more(limit=None)

        all_comments = []
        not_my_comments = []

        for comment in submission.comments.list():
            if str(comment.author) != 'None':
                all_comments.append(comment)
            if str(comment.author) != bot_name:
                not_my_comments.append(comment)

        
        # HINT: 
        # we need to make sure that our code is working correctly,
        # and you should not move on from one task to the next until you are 100% sure that 
        # the previous task is working;
        # in general, the way to check if a task is working is to print out information 
        # about the results of that task, 
        # and manually inspect that information to ensure it is correct; 
        # in this specific case, you should check the length of the all_comments variable,
        # and manually ensure that the printed length is the same as the length displayed on reddit;
        # if it's not, then there are some comments that you are not correctly identifying,
        # and you need to figure out which comments those are and how to include them.
        print('len(all_comments)=',len(all_comments))

        # FIXME (task 1): filter all_comments to remove comments that were generated by your bot
        # HINT: 
        # use a for loop to loop over each comment in all_comments,
        # and an if statement to check whether the comment is authored by you or not
        

        # HINT:
        # checking if this code is working is a bit more complicated than in the previous tasks;
        # reddit does not directly provide the number of comments in a submission
        # that were not gerenated by your bot,
        # but you can still check this number manually by subtracting the number
        # of comments you know you've posted from the number above;
        # you can use comments that you post manually while logged into your bot to know 
        # how many comments there should be. 
        print('len(not_my_comments)=',len(not_my_comments))

        # if the length of your all_comments and not_my_comments lists are the same,
        # then that means you have not posted any comments in the current submission;
        # (your bot may have posted comments in other submissions);
        # your bot will behave differently depending on whether it's posted a comment or not
        has_not_commented = len(not_my_comments) == len(all_comments)

        if has_not_commented:
            # FIXME (task 2)
            # if you have not made any comment in the thread, then post a top level comment
            #
            # HINT:
            # use the generate_comment() function to create the text,
            # and the .reply() function to post it to reddit;
            # a top level comment is created when you reply to a post instead of a message
            submission.reply(generate_comment())

        else:
            # FIXME (task 3): filter the not_my_comments list to also remove comments that 
            # you've already replied to
            # HINT:
            # there are many ways to accomplish this, but my solution uses two nested for loops
            # the outer for loop loops over not_my_comments,
            # and the inner for loop loops over all the replies of the current comment from the outer loop,
            # and then an if statement checks whether the comment is authored by you or not
            comments_without_replies = []
            for comment in not_my_comments:
                child_comments = comment.replies

                if len(child_comments) == 0:
                    comments_without_replies.append(comment)
                else:
                    no_replies = True
                    
                    for child_comment in child_comments:

                        if child_comment.author == bot_name:
                            no_replies = False
                    if no_replies == True:        
                        comments_without_replies.append(comment)

            # HINT:
            # this is the most difficult of the tasks,
            # and so you will have to be careful to check that this code is in fact working correctly
            print('len(comments_without_replies)=',len(comments_without_replies))

            # FIXME (task 4): randomly select a comment from the comments_without_replies list,
            # and reply to that comment
            #
            # HINT:
            # use the generate_comment() function to create the text,
            # and the .reply() function to post it to reddit;
            # these will not be top-level comments;
            # so they will not be replies to a post but replies to a message
            try:
                random.choice(comments_without_replies).reply(generate_comment())
            except Exception as e:
                print('ERROR: There are probably no comments without replies. The full error:\n' + str(e))
            pass

        # FIXME (task 5): select a new submission for the next iteration;
        # your newly selected submission should be randomly selected from the 5 hottest submissions

        



        # We sleep just for 1 second at the end of the while loop.
        # This doesn't avoid rate limiting
        # (since we're not sleeping for a long period of time),
        # but it does make the program's output more readable.
        time.sleep(random.randint(20,600))

    except Exception as e:
        
        print('ERROR: ' + str(e))

        try:
            sec = int(str(e)[str(e).find('for ')+4:str(e).find('for ')+6])
            if 'seconds' in str(e):
                continue
            else:
                sec = sec*60
            print('wait for ' + str(sec))
            time.sleep(sec)
        except:
            pass